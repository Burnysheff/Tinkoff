program dix;
  var i:integer;
  a,b,c,e:real;
  flag1, flag2: boolean;
  function f(x:real):real;
  begin
  f:=576*x*x*x*x*x*x*x*x*x*x*x*x*x+6080*x*x*x*x*x*x*x*x*x-96*x*x*x*x*x*x*x*x+17672*x*x*x*x*x+7280*x-2400;
  end;
  begin
  flag1:=False;
  flag2:=False;
  e:=0.00000000001;
  for i:= -2400 to 2400 do  //ответ лежит в пределах от -2400 до 2400 - значит границы поиска а и b такие; a - аргумент
    if (f(i)<0) then        // функции в точке, где она отрицательна, b - где положительна. Затем программа "сужает" область между
      begin                 // a и b путем нахождения их среднего арифметического (новой точки с аргументом c) и присваивания либо а либо b значения с (в зависимости от того, отрицательна или положительна функция в точке с).
        a:=i;               // Через какое-то время границы области а-b будут находиться в пределах погрешности от нуля.
        flag1:=True;        // Если в заданном промежутке не было найдено ни одной точки, где значение функции было бы положительным (или отрицательным), то
        break;              // программа выводит предупреждение о том, что нулей.
      end;
  for i:= -2400 to 2400 do
    if (f(i)>0) then
      begin
        b:=i;
        flag2:=True;
        break;
      end;
  if ((flag1 = False) or (flag2 = False)) then
    writeln('Ошибка! Нулей нет - значения ниже некорректны');
  while abs(a-b) > e do begin
    c:=(a+b) / 2;
    if (f(c) < 0) then
      a:=c
      else
      b:=c;
    end;
  writeln(f(c),' ',c);      // После получения значения аргумента 0,321 можно повторно запустить программу, указывая при этом такие промежутки поиска а и b, что они не могут
  end.                      // принять значения меньше или больше 0,321. Тогда окажется, что нулей функции ни до найденного значения аргумента, ни после него не существует. Это означает, что 0,321 - единственное решение.
      
      
      
